---
layout:     post
title:     《前端工程化》
subtitle:   
date:       2017-12-12
author:     hdj
header-img: img/bgs/girl-3.jpg
catalog: true
categories : [javascript]

tags:
    - 前端工程化
    - js
---



# 前言

前阵子领导买了几本书顺便弄了一本《前端工程化-体系设计与实现》凑单，问我看不看，我拉开抽屉说我这还有好几本书看不完呢。然而在我转过头撩妹的（啊，呸是工作）在转过头的时候，桌上赫然放着这么一本书。
没办法领导给的书哭着也要看完！

###第一章
  
###1.1前端工程师的基本素养
  
#### 1.1.1发展历史 
  
    不感兴趣
     1990 JavaScript 2005-ajax局部刷新，2008 Google V8 2009 nodejs
     
    
####  1.1.2 前端工程师额技能栈（全栈）
    
*    **硬技能   HTML CSS JavaScript**
*    **软技能   用户体验**
*    **扩展技能 Node.js**

### 1.2 Node.js带来的变革
 
#### 1.2.1前端的两次新生
   1. ajax 实现异步请求和局部刷新
   2. Node.js 使JavaScript进入服务端领域丰富了js的生态。
   
#### 1.2.2 Node.js带来的变革
    
   1. 服务端开发
    
   2. 同构JavaScript
    
       即令JavaScript编写的代码既能在服务端工作也可以在浏览器工作。
       
   * 传统网站渲染是服务端渲染，返回给客户端html网页，利于SEO（搜索引擎优化）
       
   * SPA单页面应用路由和渲染交由客户端，不利于SEO。优势：
      1. 减轻了服务端的压力，
      2. JSON数据体积小减少网络请求时间，
      3. 页面路由控制更快，
      4. 可以离线使用。
      
      
   3. 前端工具
       
       Grunt，webpack，Gulp
        
### 1.3 前后端分离
*     开发: 宗旨是实现并行开发，缩短开发周期
*     测试: 更快速和精准的对问题进行定位
*     部署： 简化部署流程，增强程序健壮性

## 第三章
### 3.5模块化开发
#### 3.5.1模块化与组件化
  这个有争论。书上写的和我理解的相反。
  
#### 3.5.2模块化与工程化
 补个图
#### 3.5.3模块化开发的价值

1. 避免命名冲突
2. 便于依赖管理
3. 利于性能优化
4. 提高可维护性
5. 利于代码复用   

#### 3.5.4前端模块化发展史

1. CommonJS 只适用于JavaScript的静态模块化罚款规范，适合Node.js开发，因为
   *  浏览器资源包括js，css，图片等。CommonJS无法处理
   *  CommonJS所有模块是同步上阻塞试加载无法实现按需异步加载

2. AMD/CMD -着力于浏览器的模块化规范

   AMD/CMD虽非完全一致，核心是统一的，在CommonjS基础上提供了一下功能：
   
   *  可以处理js以外的资源
   *  源码无需编译可在浏览器下运行
   *  按需异步加载，并行加载
   *  插件系统
   
   
   缺点如下：
   
   1.  应用场景单一，模块无法跨环境运行
   2. 构建环境不统一
   3. 不同规范的模块不能混用，模块复用性不高
   4. 未来不可期（ES6 Module的缘故）
   
3. ES6 Module 规范的静态模块体系 
   import（）webpack babel 已支持，未来尤可期也。
   
#### 3.5.5webpack 模块化构建
  webpack 支持CommonJS，AMD，ES6 Moudle，但存在差异：
  
   1. 规范差异性
    * CommonJS用于Node.js开发，不具备异步加载的功能。需要借助webpack的API实现。
    *  AMD虽然面向浏览器也具备异步加载的功能。但是webpack在构建AMD规范的异步模块式不能定义输出的文件名称，导致AMD异步文件的名称欠缺语义。
    *  ES6Moudle不支持异步加载。import已被webpack支持。
    