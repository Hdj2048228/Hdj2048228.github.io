---
layout:     post
title:      leetcode刷题（三）
subtitle:   小算法大智慧 
date:       2017-12-07
author:     hdj
header-img: img/bgs/girl-3.jpg
catalog: true
tags:
    - 算法
    - 各种算法
---



# 前言

 最近在[leetcode](https://leetcode.com/)上做算法题，记录一下心得

  （我的答案是用js写的）
##  由易至难

### 第一题：104 Maximum Depth of Binary Tree

    
>  Given a binary tree, find its maximum depth.
  
>  The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
  

#### 解
  
        var maxDepth = function(root) {
            if(!root){return 0;}
            
            return Math.max(maxDepth(root.left),maxDepth(root.right))+1;
            };
    
   
  
### 第二题 226. Invert Binary Tree

> Invert a binary tree.

     4
   /   \
  2     7
 / \   / \
1   3 6   9
to
     4
   /   \
  7     2
 / \   / \
9   6 3   1


> Trivia:

	``
			This problem was inspired by this original tweet 	by Max Howell:
		
		Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.
	
	``

### 解

    var invertTree = function(root) {
        if (!root) {
            return root;
        }
        
        const { right, left } = root;
        
        root.left = invertTree(right);
        root.right = invertTree(left);
        
        return root;
    };
  

###第三题 695. Max Area of Island     
> Given a non-empty 2D array grid of 0's and 1's, an island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.

> Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)

**Example 1:**
    `
    [[0,0,1,0,0,0,0,1,0,0,0,0,0],
     [0,0,0,0,0,0,0,1,1,1,0,0,0],
     [0,1,1,0,1,0,0,0,0,0,0,0,0],
     [0,1,0,0,1,1,0,0,1,0,1,0,0],
     [0,1,0,0,1,1,0,0,1,1,1,0,0],
     [0,0,0,0,0,0,0,0,0,0,1,0,0],
     [0,0,0,0,0,0,0,1,1,1,0,0,0],
     [0,0,0,0,0,0,0,1,1,0,0,0,0]]
     `
     
>Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally.

**Example 2:**

        `[[0,0,0,0,0,0,0,0]]
        `
>Given the above grid, return 0.

**Note: The length of each dimension in the given grid does not exceed 50.**
   
#### 译

 给定一个二维数组，计算其中最大岛屿的面积。
 **（注意形成岛屿的规则）**

#### 解

        var maxAreaOfIsland = function(grid) {
            var max = 0;
            if(grid == null && grid.length == 0){
               return max;
              }
            
            var m = grid.length;
            var n = grid[0].length;
            for(var i = 0;i < m;i++){
                for(var j = 0;j < n;j++){
                    if(grid[i][j] == 1){ // 值为1时遍历相加
                        var area = deps(grid,i,j,m,n,0);  // 递归调用
                        max =  Math.max(max,area);  // 取最大值
                     }
                 
               }
            }
            return max;
        };
        function deps (grid,i,j,m,n,area){
          
            // 数组越界以及grid[i][j] 为0时返回area
            if(i<0 || j< 0 || i>=m || j>=n ||grid[i][j] == 0 ){
                return area;
            }
            // else grid[i][j] == 1 时，
            grid[i][j] = 0; // 这一步使其为0，防止多次递归。
            area ++;  // 面积加 1
            // 递归调用
            area = deps(grid,i-1,j,m,n,area);
            area = deps(grid,i,j-1,m,n,area);
            area = deps(grid,i+1,j,m,n,area);
            area = deps(grid,i,j+1,m,n,area);
            return area;
        }
              
         `   
    
#### 思考
  
   这个题目算是简单中的比较难得题目了，主要是判断条件比较多而且遍历循环比较复杂。
   
   思路上无非是先循环遍历二维数组，遇到为1的情况，计算其上下左右是否为1，为1则面积加1，此时需要判断数组是否越界，
   以及将当前数组位置的grid[i][j] 置为 0 ，这样可以避免循环遍历，使用递归遍历其上下左右的值。
   
   
###第四题 744. Find Smallest Letter Greater Than Target   

> Given a list of sorted characters letters containing only lowercase letters, and given a target letter target, find the smallest element in the list that is larger than the given target.
> 
> Letters also wrap around. For example, if the target is target = 'z' and letters = ['a', 'b'], the answer is 'a'.


**Examples:**

            Input:
            letters = ["c", "f", "j"]
            target = "a"
            Output: "c"
            
            Input:
            letters = ["c", "f", "j"]
            target = "c"
            Output: "f"
            
            Input:
            letters = ["c", "f", "j"]
            target = "d"
            Output: "f"
            
            Input:
            letters = ["c", "f", "j"]
            target = "g"
            Output: "j"
            
            Input:
            letters = ["c", "f", "j"]
            target = "j"
            Output: "c"
            
            Input:
            letters = ["c", "f", "j"]
            target = "k"
            Output: "c"
            
 **Note:**
 
  1. letters has a length in range [2, 10000].
  
  2. letters consists of lowercase letters, and contains at least 2 unique letters.
  
  3. target is a lowercase letter.   
      
      
#### 题目简析
 
   这道题是一道比较简单的问题，需要注意的问题是
   
   1.  数组是有序的
    
   2. 找不到返回第一个
   
 #### 解
 
      var nextGreatestLetter = function(letters, target) {
           for (var i = 0; i < letters.length; i++) {
           // 遍历整个数组
               var c = letters[i];
              if (c > target){return c;} 
           }
         //如果遍历完都没有返回，就返回第一个元素
         return letters[0];
         };