---
layout:     post
title:      leetcode刷题
subtitle:   小算法大智慧
date:       2017-11-16
author:     hdj
header-img: img/bgs/girl-3.jpg
catalog: true
tags:
    - 算法
    - 各种算法
---



# 前言

 最近在[leetcode](https://leetcode.com/)上做算法题，记录一下心得

  （我的答案是用js写的）
##  由易至难

### 第一题：
  Given an array of integers, return indices of the two numbers such that they add up to a specific target.
  
  You may assume that each input would have exactly one solution, and you may not use the same element twice.
  
  Example:
  Given nums = [2, 7, 11, 15], target = 9,
  
  Because nums[0] + nums[1] = 2 + 7 = 9,
  return [0, 1].
  
#### 我的答案：
  
  
    
     var twoSum = function(nums, target) {
   
      var l  = nums.length;
      var b = [];
      for(var i= 0 ;i < l; i++){
          for(var j = i+1 ;j < l;j++){
            if(nums[i] + nums[j] == target){
             b.push(i);
             b.push(j);
            }  
          }
          
      }
      return b;
      };
  
#### 官方：
   **1. Approach #1 (Brute Force) [Accepted]**
  
  最直观的方法遍历每个元素的值和该元素的下一个的值是相加是否等于target的值。

  
    public int[] twoSum(int[] nums, int target) {
      for (int i = 0; i < nums.length; i++) {
          for (int j = i + 1; j < nums.length; j++) {
              if (nums[j] == target - nums[i]) {
                  return new int[] { i, j };
              }
          }
      }
      throw new IllegalArgumentException("No two sum solution");
    }
  
  算法分析：
   时间复杂度：O(n²)。对每一个元素都通过循环找到剩余数组的其他元素的O（n）次。
  
   空间复杂度：O（1）。
   
   **2. Approach #2 (Two-pass Hash Table  二次哈希表) [Accepted]**
     
   为了提高我们的运行时间复杂度，我们需要一个更有效的方法来检查数组中的指数是否存在。
   如果指数存在，我们需要查找它的索引。在数组中维护每个元素的映射的最佳方法是什么?一个哈希表。
  
   我们以交易空间换取速度将查找时间从o（n）到o（1）到o。哈希表正是为了这个目的而构建的，它支持在几乎恒定的时间内快速查找。之所以说“近乎”，
   最坏的情况下，查询时间可能为O（n）。
   ```
   public int[] twoSum(int[] nums, int target) {
       Map<Integer, Integer> map = new HashMap<>();
       for (int i = 0; i < nums.length; i++) {
           map.put(nums[i], i);
       }
       for (int i = 0; i < nums.length; i++) {
           int complement = target - nums[i];
           if (map.containsKey(complement) && map.get(complement) != i) {
               return new int[] { i, map.get(complement) };
           }
       }
       throw new IllegalArgumentException("No two sum solution");
   }
   ```
   
     
  算法分析：
     
   时间复杂度：O（n）。通过将数组放到hashmap中，并利用for循环遍历元素，通过tagert - i 的值，判断map是否含有这个值，且这个值（y）不和
     i相等， 则返回i，这返回[i,y],这样算法的时间复杂度为O（n）；
     
   空间复杂度：O（n）。需要额外的空间存储数组，且和n成线性关系。
     
 **3. Approach #3 (One-pass Hash Table 一次哈希表) [Accepted]**
  
   我们还可以一次完成。当我们在表中迭代并插入元素时，我们还会回顾一下，看看当前元素的补充是否已经存在于表中。如果存在，我们已经找到了解决方
   案，并立即返回。
 
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement)) {
                return new int[] { map.get(complement), i };
            }
            map.put(nums[i], i);
        }
        throw new IllegalArgumentException("No two sum solution");
    }
   
  同2：此方案的优化是在插入的时候就判断是否有元素，少了一次遍历的操作。
   
   
### 第二题  561. Array Partition I    
 
 >  Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ...,
 >   (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.
 >  
 >  Example 1:
 >  Input: [1,4,3,2]
 >  
 >  Output: 4
 >  Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).
 >  Note:
 >  n is a positive integer, which is in the range of [1, 10000].
 >  All the integers in the array will be in the range of [-10000, 10000].
 >  

 本题是为了求一个最大最小值问题，看懂题目之后我们容易发现其实最终问题可以转化为将数组进行排序，然后各一个求和，因为为了使最后的和最大，我们
  需要让最大值和第二大值在一个数对里面，依次类推，只有这样才能使“资源浪费最少”
 
#### 我的答案
   ```
   var arrayPairSum = function(nums) {
   
      var nums = nums.sort(
          function(a,b){
            if (a>b) {
                 return 1;
             }else if(a<b){
                return -1
            }else{
              return 0;
            }    
       }
       );
       var result = 0;
       var l =  nums.length
       for(var i = 0 ;i < l;i+=2){
          result += nums[i]
       }
       return result;
   };
   ```
     
     
     
     
     
     
     
     
     
     