---
layout:     post
title:      leetcode刷题
subtitle:   小算法大智慧
date:       2017-11-16
author:     hdj
header-img: img/bgs/girl-3.jpg
catalog: true
tags:
    - 算法
    - 各种算法
---



# 前言

 最近在[leetcode](https://leetcode.com/)上做算法题，记录一下心得

  （我的答案是用js写的）
##  由易至难

### 第一题： 1. Two Sum

  Given an array of integers, return indices of the two numbers such that they add up to a specific target.
  
  You may assume that each input would have exactly one solution, and you may not use the same element twice.
  
  Example:
  Given nums = [2, 7, 11, 15], target = 9,
  
  Because nums[0] + nums[1] = 2 + 7 = 9,
  return [0, 1].
  
#### 我的答案：
  
  
    
     var twoSum = function(nums, target) {
   
      var l  = nums.length;
      var b = [];
      for(var i= 0 ;i < l; i++){
          for(var j = i+1 ;j < l;j++){
            if(nums[i] + nums[j] == target){
             b.push(i);
             b.push(j);
            }  
          }
          
      }
      return b;
      };
  
#### 官方：
   **1. Approach #1 (Brute Force) [Accepted]**
  
  最直观的方法遍历每个元素的值和该元素的下一个的值是相加是否等于target的值。

  
    public int[] twoSum(int[] nums, int target) {
      for (int i = 0; i < nums.length; i++) {
          for (int j = i + 1; j < nums.length; j++) {
              if (nums[j] == target - nums[i]) {
                  return new int[] { i, j };
              }
          }
      }
      throw new IllegalArgumentException("No two sum solution");
    }
  
  算法分析：
   时间复杂度：O(n²)。对每一个元素都通过循环找到剩余数组的其他元素的O（n）次。
  
   空间复杂度：O（1）。
   
   **2. Approach #2 (Two-pass Hash Table  二次哈希表) [Accepted]**
     
   为了提高我们的运行时间复杂度，我们需要一个更有效的方法来检查数组中的指数是否存在。
   如果指数存在，我们需要查找它的索引。在数组中维护每个元素的映射的最佳方法是什么?一个哈希表。
  
   我们以交易空间换取速度将查找时间从o（n）到o（1）到o。哈希表正是为了这个目的而构建的，它支持在几乎恒定的时间内快速查找。之所以说“近乎”，
   最坏的情况下，查询时间可能为O（n）。
   ```
   public int[] twoSum(int[] nums, int target) {
       Map<Integer, Integer> map = new HashMap<>();
       for (int i = 0; i < nums.length; i++) {
           map.put(nums[i], i);
       }
       for (int i = 0; i < nums.length; i++) {
           int complement = target - nums[i];
           if (map.containsKey(complement) && map.get(complement) != i) {
               return new int[] { i, map.get(complement) };
           }
       }
       throw new IllegalArgumentException("No two sum solution");
   }
   ```
   
     
  算法分析：
     
   时间复杂度：O（n）。通过将数组放到hashmap中，并利用for循环遍历元素，通过tagert - i 的值，判断map是否含有这个值，且这个值（y）不和
     i相等， 则返回i，这返回[i,y],这样算法的时间复杂度为O（n）；
     
   空间复杂度：O（n）。需要额外的空间存储数组，且和n成线性关系。
     
 **3. Approach #3 (One-pass Hash Table 一次哈希表) [Accepted]**
  
   我们还可以一次完成。当我们在表中迭代并插入元素时，我们还会回顾一下，看看当前元素的补充是否已经存在于表中。如果存在，我们已经找到了解决方
   案，并立即返回。
 
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement)) {
                return new int[] { map.get(complement), i };
            }
            map.put(nums[i], i);
        }
        throw new IllegalArgumentException("No two sum solution");
    }
   
  同2：此方案的优化是在插入的时候就判断是否有元素，少了一次遍历的操作。
   
   
### 第二题  561. Array Partition I    
 
 >  Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ...,
 >   (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.
 >  
 >  Example 1:
 >  Input: [1,4,3,2]
 >  
 >  Output: 4
 >  Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).
 >  Note:
 >  n is a positive integer, which is in the range of [1, 10000].
 >  All the integers in the array will be in the range of [-10000, 10000].
 >  

 本题是为了求一个最大最小值问题，看懂题目之后我们容易发现其实最终问题可以转化为将数组进行排序，然后各一个求和，因为为了使最后的和最大，我们
  需要让最大值和第二大值在一个数对里面，依次类推，只有这样才能使“资源浪费最少”
 
#### 我的答案
   ```
   var arrayPairSum = function(nums) {
   
      var nums = nums.sort(
          function(a,b){
            if (a>b) {
                 return 1;
             }else if(a<b){
                return -1
            }else{
              return 0;
            }    
       }
       );
       var result = 0;
       var l =  nums.length
       for(var i = 0 ;i < l;i+=2){
          result += nums[i]
       }
       return result;
   };
   ```
### 第三题 728. Self Dividing Numbers
   
   > A self-dividing number is a number that is divisible by every digit it contains.
   > 
   > For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.
   > 
   > Also, a self-dividing number is not allowed to contain the digit zero.
   > 
   > Given a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible.
   > 
   > Example 1:
   > Input: 
   > left = 1, right = 22
   > Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]
   > Note:
   > 
   > The boundaries of each input argument are 1 <= left <= right <= 10000.
     
####  我的答案
   
   
     var selfDividingNumbers = function(left, right) {
         var result = [];
         for(var i = left;i <= right;i++){
           if(canDivde(i)){
              result.push(i); 
           }
         }
         return result;
     }
     var canDivde = function(number){
         var str = number + '';
         var l = str.length;
         var can = true;
         for( var i = 0 ; i < l  ;i++){
             var number_i = str.charAt(i);
             if(number%number_i !== 0){
               can = false;
               break;
             }
         }
         return can;
     };
     
#### 官方答案
   
     class Solution {
         public List<Integer> selfDividingNumbers(int left, int right) {
             List<Integer> ans = new ArrayList();
             for (int n = left; n <= right; ++n) {
                 if (selfDividing(n)) ans.add(n);
             }
             return ans;
         }
         public boolean selfDividing(int n) {
             for (char c: String.valueOf(n).toCharArray()) {
                 if (c == '0' || (n % (c - '0') > 0))
                     return false;
             }
             return true;
         }
     }
      
   解题思路：根据输入的值从left-right遍历其中的值，对每一个值得每一位进行自除检测，有一位不能整除则返回false。
   
   **算法分析**
   
   时间复杂度：D= right - left考虑最坏情况，数组中的每一位都是和right一样长，所以最多要循环（D * right.length ）次 O（D*log（Right））
   
   空间复杂度：O(D)需要分配空间对l-r进行计算。
   
### 第四题 461. Hamming Distance 汉明距离
   > The Hamming distance between two integers is the number of positions at which the corresponding bits are different.
   > 
   > Given two integers x and y, calculate the Hamming distance.
   > 
   > Note:
   > 0 ≤ x, y < 231.
   > 
   > Example:
   > 
   > Input: x = 1, y = 4
   > 
   > Output: 2
   > 
   > Explanation:
   > 1   (0 0 0 1)
   > 4   (0 1 0 0)
   >        ↑   ↑
   > 
   > The above arrows point to positions where the corresponding bits are different.
     
     
 分析： 关键是在二进制位如何计算1的个数上。有两个方法：
     
     将num和0x1进行与操作，结果是1，代表num的最右位是1，否则是0，然后将num右移一位，循环判断，结束条件为num===0
     将num和num-1进行与操作，该操作会将num中最右边的为1的二进制位变为0（注意是最右边的1，而不是最右边的位），循环计算，结束条件为num===0
     
     
 答案：
 
             var hammingDistance = function(x, y) {
              var count = 0;
              var n = x ^ y;
              while (n) {
                ++count;
                n = (n - 1) & n;
              }
              return count;
             };    
      
 
       
 备注：
 ^ 运算符随后查看两个表达式的二进制表示形式的值，并执行按位“异或”运算。此运算的结果如下所示：
 `JavaScript
    0101   (expression1)
    1100   (expression2)
    ----
   1001   (result)
 `
 **^ 当且仅当只有一个表达式的某位为 1 时，结果中的该位才为 1。否则，结果中的该位为 0。**
 
 **& 对两个 32 位表达式的每一个位执行按位“与”运算。 如果两个位均为 1，则结果是 1。 否则，结果为 0。**